<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mökin sää</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<style>
  :root { --bg:#0e1116; --card:#171b22; --fg:#eaeef5; --muted:#a8b3c7; --accent:#7cc5ff; }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg);}
  header{padding:24px 16px; text-align:center}
  h1{margin:0 0 8px 0; font-size:clamp(20px, 3vw, 28px)}
  .subtitle{color:var(--muted); font-size:14px}
  .wrap{max-width:1100px; margin:0 auto; padding:16px}
  .cards{display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:12px; margin-bottom:16px}
  .card{background:var(--card); border:1px solid #222834; border-radius:12px; padding:16px}
  .label{color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.06em}
  .value{font-size:28px; margin-top:6px}
  .updated{color:var(--muted); font-size:12px; margin-top:6px}
  .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:12px 0 16px}
  select,button{background:#0f131a; color:var(--fg); border:1px solid #2a3140; border-radius:10px; padding:8px 10px; cursor:pointer}
  button:hover,select:hover{border-color:#3a4356}
  .panel{background:var(--card); border:1px solid #222834; border-radius:12px; padding:12px 12px 18px; margin-bottom:16px}
  canvas{width:100%; height:320px}
  footer{color:var(--muted); font-size:12px; text-align:center; padding:24px}
  a{color:var(--accent); text-decoration:none}
  a:hover{text-decoration:underline}
</style>
</head>
<body>
  <header>
    <h1>Mökin sää</h1>
    <div class="subtitle">ThingSpeak → GitHub Pages</div>
  </header>

  <div class="wrap">
    <div class="cards">
      <div class="card">
        <div class="label">Lämpötila</div>
        <div class="value" id="tempVal">–</div>
        <div class="updated" id="tempTime">—</div>
      </div>
      <div class="card">
        <div class="label">Kosteus</div>
        <div class="value" id="humVal">–</div>
        <div class="updated" id="humTime">—</div>
      </div>
      <div class="card">
        <div class="label">Ilmanpaine</div>
        <div class="value" id="pressVal">–</div>
        <div class="updated" id="pressTime">—</div>
      </div>
    </div>

    <div class="panel">
      <div class="controls">
        <label for="rangeSel" class="label" style="margin-right:6px;">Aikaväli</label>
        <select id="rangeSel">
          <option value="1d">Viimeinen päivä</option>
          <option value="3d">3 päivää</option>
          <option value="7d" selected>7 päivää</option>
          <option value="30d">30 päivää</option>
          <option value="90d">90 päivää</option>
        </select>
        <button id="refreshBtn">Päivitä</button>
      </div>
      <canvas id="tempChart"></canvas>
    </div>

    <div class="panel">
      <canvas id="humChart"></canvas>
    </div>

    <div class="panel">
      <canvas id="pressChart"></canvas>
    </div>
  </div>

  <footer>
    Päivittyy suoraan ThingSpeakistä selaimessa. Jos kanava on private, lisää READ API Key koodiin.
  </footer>

<script>
/* ========= MUOKKAA NÄMÄ ========= */
const CHANNEL_ID = '3028480';  // esim. "1234567"
const READ_API_KEY = 'BECW0OWUXX79PC39'; // jos public-kanava, jätä tyhjäksi. Muuten esim. "ABCDE..."
const FIELD_TEMP  = 1;   // lämpötila fieldi #
const FIELD_HUM   = 2;   // kosteus fieldi #
const FIELD_PRESS = 3;   // paine fieldi #
/* ================================= */

const rangeSel   = document.getElementById('rangeSel');
const refreshBtn = document.getElementById('refreshBtn');

const el = {
  tempVal:  document.getElementById('tempVal'),
  tempTime: document.getElementById('tempTime'),
  humVal:   document.getElementById('humVal'),
  humTime:  document.getElementById('humTime'),
  pressVal: document.getElementById('pressVal'),
  pressTime:document.getElementById('pressTime'),
};

let charts = {};

function fmtNum(x, digits=1) {
  const n = parseFloat(x);
  if (Number.isFinite(n)) return n.toFixed(digits).replace('.', ',');
  return '–';
}
function fmtTime(iso) {
  if (!iso) return '—';
  const d = new Date(iso);
  return d.toLocaleString('fi-FI', { hour12:false });
}
function toUrlDays(days) {
  // ThingSpeak tukee &days=N (takautuva N päivää) tai &start=&end=
  const params = new URLSearchParams();
  if (READ_API_KEY) params.set('api_key', READ_API_KEY);
  params.set('days', String(days));
  // rajataan maks. 8000 riviin, muuta tarpeen mukaan
  params.set('timezone', 'Europe/Helsinki');
  params.set('offset', '0');
  params.set('limit', '8000');
  return `https://api.thingspeak.com/channels/${CHANNEL_ID}/feeds.json?${params.toString()}`;
}
function parseRangeValue(val) {
  if (val.endsWith('d')) return parseInt(val,10);
  return 7;
}
async function fetchData(days){
  const url = toUrlDays(days);
  const res = await fetch(url);
  if (!res.ok) throw new Error('ThingSpeak haku epäonnistui');
  const json = await res.json();
  return json;
}

function makeDataset(feeds, fieldNo, label) {
  const data = [];
  const labels = [];
  for (const f of feeds) {
    const v = f[`field${fieldNo}`];
    if (v !== null && v !== undefined && v !== '') {
      labels.push(new Date(f.created_at));
      data.push(Number(v));
    }
  }
  return { labels, data, label };
}

function ensureChart(ctx, cfgKey, labels, data, seriesLabel, unit) {
  const config = {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: seriesLabel,
        data,
        fill: false,
        tension: 0.2,
        borderWidth: 2,
        pointRadius: 0,
      }]
    },
    options: {
      responsive: true,
      interaction: { mode: 'nearest', intersect: false },
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y;
              return `${seriesLabel}: ${v}${unit ? ' ' + unit : ''}`;
            }
          }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: { tooltipFormat: 'dd.MM.yyyy HH:mm', displayFormats: { hour: 'dd.MM HH:mm', day:'dd.MM' } },
          ticks: { autoSkip: true, maxTicksLimit: 9 }
        },
        y: { beginAtZero: false }
      }
    }
  };
  if (charts[cfgKey]) {
    charts[cfgKey].data.labels = labels;
    charts[cfgKey].data.datasets[0].data = data;
    charts[cfgKey].update();
  } else {
    charts[cfgKey] = new Chart(ctx, config);
  }
}

function updateLatestCard(feeds, fieldNo, valueEl, timeEl, suffix) {
  // etsitään viimeisin feed jolla on arvo
  for (let i = feeds.length - 1; i >= 0; i--) {
    const f = feeds[i];
    const v = f[`field${fieldNo}`];
    if (v !== null && v !== undefined && v !== '') {
      valueEl.textContent = `${fmtNum(v)}${suffix ? ' ' + suffix : ''}`;
      timeEl.textContent  = `Päivitetty: ${fmtTime(f.created_at)}`;
      return;
    }
  }
  valueEl.textContent = '–';
  timeEl.textContent  = '—';
}

async function render(){
  try {
    const days = parseRangeValue(rangeSel.value);
    const { feeds } = await fetchData(days);

    // Päivitä kortit
    updateLatestCard(feeds, FIELD_TEMP,  el.tempVal,  el.tempTime,  '°C');
    updateLatestCard(feeds, FIELD_HUM,   el.humVal,   el.humTime,   '%');
    updateLatestCard(feeds, FIELD_PRESS, el.pressVal, el.pressTime, 'hPa');

    // Datasetit + käyrät
    const t = makeDataset(feeds, FIELD_TEMP,  'Lämpötila');
    const h = makeDataset(feeds, FIELD_HUM,   'Kosteus');
    const p = makeDataset(feeds, FIELD_PRESS, 'Ilmanpaine');

    // Piirrä
    ensureChart(document.getElementById('tempChart'),  'temp',  t.labels, t.data, 'Lämpötila', '°C');
    ensureChart(document.getElementById('humChart'),   'hum',   h.labels, h.data, 'Kosteus', '%');
    ensureChart(document.getElementById('pressChart'), 'press', p.labels, p.data, 'Ilmanpaine', 'hPa');

  } catch(e) {
    console.error(e);
    alert('Datan haku epäonnistui. Tarkista CHANNEL_ID ja API Key.');
  }
}

rangeSel.addEventListener('change', render);
refreshBtn.addEventListener('click', render);

// Chart.js time scale tarvitsee adapterin – käytetään built-in Intl ilman ulkoista libiä:
Chart.registry.addScales(Chart.registry.getScale('time')); // varmistus, yleensä ei tarvita

render();
</script>
</body>
</html>
